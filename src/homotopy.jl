transformer(eq) = transformer(ops(eq)...)

function transformer(::Mul, eq)
    return vcat([transformer(t) for t in arguments(eq)]...)
end

function transformer(::Div, eq)
    a = transformer(arguments(eq)[1])
    b = transformer(arguments(eq)[2])
    b = [(1 / q, k) for (q, k) in b]
    return [a; b]
end

function transformer(::Pow, eq)
    y, k = arguments(eq)
    if is_number(k)
        r = nice_parameter(k)
        if r isa Integer || r isa Rational
            if denominator(r) == 1
                return [(y, k)]
            else
                return [(y^(1 / denominator(r)), numerator(r))]
            end
        end
    end
    return [(eq, 1)]
end

function transformer(::Any, eq)
    return [(eq, 1)]
end

function transform(eq, x)
    p = transformer(eq)
    p = p[isdependent.(first.(p), x)]
    return p
end

@syms u[20]

function rename_factors(p, ab = ())
    n = length(p)
    q = 1
    ks = Int[]
    sub = Dict()

    for (a, b) in ab
        sub[a] = b
    end

    for (i, (y, k)) in enumerate(p)
        Œº = u[i]
        q *= Œº^k
        sub[Œº] = y
        push!(ks, k)
    end

    return q, sub, ks
end

##############################################################################

Symbolics.@register_symbolic Ei(z)
Symbolics.@register_symbolic Si(z)
Symbolics.@register_symbolic Ci(z)
Symbolics.@register_symbolic Li(z)
Symbolics.@register_symbolic Erfi(z)

Symbolics.derivative(::typeof(Ei), args::NTuple{1, Any}, ::Val{1}) = exp(args[1]) / args[1]
Symbolics.derivative(::typeof(Si), args::NTuple{1, Any}, ::Val{1}) = sin(args[1]) / args[1]
Symbolics.derivative(::typeof(Ci), args::NTuple{1, Any}, ::Val{1}) = cos(args[1]) / args[1]
Symbolics.derivative(::typeof(Li), args::NTuple{1, Any}, ::Val{1}) = 1 / log(args[1])
function Symbolics.derivative(::typeof(Erfi), args::NTuple{1, Any}, ::Val{1})
    2 / sqrt(2) * exp(args[1]^2)
end

@syms ùë• si(ùë•) ci(ùë•) ei(ùë•) li(ùë•) erfi_(ùë•)

##############################################################################

guard_zero(x) = isequal(x, 0) ? one(x) : x

# The core of ansatz generation.
# The name is not accurate and should be changed (not really homotopy, 
# just inspired from!)
function generate_homotopy(eq, x)
    eq = value(eq)
    x = value(x)

    if is_add(eq)
        return unique(union([generate_homotopy(t, x) for t in args(eq)]...))
    end

    p = transform(eq, x)
    q, sub, ks = rename_factors(p, (si => Si, ci => Ci, ei => Ei, li => Li, erfi_ => Erfi))
    S = 0

    for i in 1:length(ks)
        Œº = u[i]
        y, dy = apply_partial_int_rules(sub[Œº], x)

        y = substitute(y, sub)
        ‚àÇy = guard_zero(diff(dy, x))

        for j in 1:ks[i]
            h = substitute((q / Œº^j) / ‚àÇy, sub)
            S += expand((œâ + y) * (œâ + h))
        end
    end

    S = substitute(S, Dict(œâ => 1))
    unique([x; [equivalent(t, x) for t in terms(S)]])
end

########################## Main Integration Rules ##################################

@syms ùõ∑(x, u)

partial_int_rules = [
                     # trigonometric functions
                     @rule ùõ∑(~x, sin(~u)) => (cos(~u) + si(~u), ~u)
                     @rule ùõ∑(~x, cos(~u)) => (sin(~u) + ci(~u), ~u)
                     @rule ùõ∑(~x, tan(~u)) => (log(cos(~u)), ~u)
                     @rule ùõ∑(~x, csc(~u)) => (log(csc(~u) + cot(~u)) + log(sin(~u)), ~u)
                     @rule ùõ∑(~x, sec(~u)) => (log(sec(~u) + tan(~u)) + log(cos(~u)), ~u)
                     @rule ùõ∑(~x, cot(~u)) => (log(sin(~u)), ~u)
                     # hyperbolic functions
                     @rule ùõ∑(~x, sinh(~u)) => (cosh(~u), ~u)
                     @rule ùõ∑(~x, cosh(~u)) => (sinh(~u), ~u)
                     @rule ùõ∑(~x, tanh(~u)) => (log(cosh(~u)), ~u)
                     @rule ùõ∑(~x, csch(~u)) => (log(tanh(~u / 2)), ~u)
                     @rule ùõ∑(~x, sech(~u)) => (atan(sinh(~u)), ~u)
                     @rule ùõ∑(~x, coth(~u)) => (log(sinh(~u)), ~u)
                     # 1/trigonometric functions
                     @rule ùõ∑(~x, 1 / sin(~u)) => (log(csc(~u) + cot(~u)) + log(sin(~u)), ~u)
                     @rule ùõ∑(~x, 1 / cos(~u)) => (log(sec(~u) + tan(~u)) + log(cos(~u)), ~u)
                     @rule ùõ∑(~x, 1 / tan(~u)) => (log(sin(~u)) + log(tan(~u)), ~u)
                     @rule ùõ∑(~x, 1 / csc(~u)) => (cos(~u) + log(csc(~u)), ~u)
                     @rule ùõ∑(~x, 1 / sec(~u)) => (sin(~u) + log(sec(~u)), ~u)
                     @rule ùõ∑(~x, 1 / cot(~u)) => (log(cos(~u)) + log(cot(~u)), ~u)
                     # 1/hyperbolic functions
                     @rule ùõ∑(~x, 1 / sinh(~u)) => (log(tanh(~u / 2)) + log(sinh(~u)), ~u)
                     @rule ùõ∑(~x, 1 / cosh(~u)) => (atan(sinh(~u)) + log(cosh(~u)), ~u)
                     @rule ùõ∑(~x, 1 / tanh(~u)) => (log(sinh(~u)) + log(tanh(~u)), ~u)
                     @rule ùõ∑(~x, 1 / csch(~u)) => (cosh(~u) + log(csch(~u)), ~u)
                     @rule ùõ∑(~x, 1 / sech(~u)) => (sinh(~u) + log(sech(~u)), ~u)
                     @rule ùõ∑(~x, 1 / coth(~u)) => (log(cosh(~u)) + log(coth(~u)), ~u)
                     # inverse trigonometric functions
                     @rule ùõ∑(~x, asin(~u)) => (~u * asin(~u) + sqrt(1 - ~u * ~u), ~u)
                     @rule ùõ∑(~x, acos(~u)) => (~u * acos(~u) + sqrt(1 - ~u * ~u), ~u)
                     @rule ùõ∑(~x, atan(~u)) => (~u * atan(~u) + log(~u * ~u + 1), ~u)
                     @rule ùõ∑(~x, acsc(~u)) => (~u * acsc(~u) + atanh(1 - ^(~u, -2)), ~u)
                     @rule ùõ∑(~x, asec(~u)) => (~u * asec(~u) + acosh(~u), ~u)
                     @rule ùõ∑(~x, acot(~u)) => (~u * acot(~u) + log(~u * ~u + 1), ~u)
                     # inverse hyperbolic functions
                     @rule ùõ∑(~x, asinh(~u)) => (~u * asinh(~u) + sqrt(~u * ~u + 1), ~u)
                     @rule ùõ∑(~x, acosh(~u)) => (~u * acosh(~u) + sqrt(~u * ~u - 1), ~u)
                     @rule ùõ∑(~x, atanh(~u)) => (~u * atanh(~u) + log(~u + 1), ~u)
                     @rule ùõ∑(~x, acsch(~u)) => (acsch(~u), ~u)
                     @rule ùõ∑(~x, asech(~u)) => (asech(~u), ~u)
                     @rule ùõ∑(~x, acoth(~u)) => (~u * acot(~u) + log(~u + 1), ~u)
                     # logarithmic and exponential functions
                     @rule ùõ∑(~x, log(~u)) => (
                         ~u + ~u * log(~u) +
                         sum(pow_minus_rule(~u, ~x, -1); init = one(~u)),
                         ~u)
                     @rule ùõ∑(~x, 1 / log(~u)) => (log(log(~u)) + li(~u), ~u)
                     @rule ùõ∑(~x, exp(~u)) => (exp(~u) + ei(~u) + erfi_(~x), ~u)
                     @rule ùõ∑(~x, ^(exp(~u), ~k::is_neg)) => (^(exp(-~u), -~k), ~u)
                     # square-root functions
                     @rule ùõ∑(~x, ^(~u, ~k::is_abs_half)) => (
                         sum(sqrt_rule(~u, ~x, ~k); init = one(~u)), ~u)
                     @rule ùõ∑(~x, sqrt(~u)) => (
                         sum(sqrt_rule(~u, ~x, 0.5); init = one(~u)), ~u)
                     @rule ùõ∑(~x, 1 / sqrt(~u)) => (
                         sum(sqrt_rule(~u, ~x, -0.5); init = one(~u)), ~u)
                     # rational functions                                                              
                     @rule ùõ∑(~x, 1 / ^(~u::is_univar_poly, ~k::is_pos_int)) => (
                         sum(pow_minus_rule(~u,
                                 ~x,
                                 -~k);
                             init = one(~u)),
                         ~u)
                     @rule ùõ∑(~x, 1 / ~u::is_univar_poly) => (
                         sum(pow_minus_rule(~u, ~x, -1); init = one(~u)),
                         ~u)
                     @rule ùõ∑(~x, ^(~u, -1)) => (log(~u) + ~u * log(~u), ~u)
                     @rule ùõ∑(~x, ^(~u, ~k::is_neg_int)) => (
                         sum(^(~u, i) for i in (~k + 1):-1), ~u)
                     @rule ùõ∑(~x, 1 / ~u) => (log(~u), ~u)
                     @rule ùõ∑(~x, ^(~u, ~k::is_pos_int)) => (
                         sum(^(~u, i + 1) for i in 1:(~k + 1)), ~u)
                     @rule ùõ∑(~x, 1) => (ùë•, 1)
                     @rule ùõ∑(~x, ~u) => ((~u + ^(~u, 2)), ~u)]

function apply_partial_int_rules(eq, x)
    y, dy = Chain(partial_int_rules)(ùõ∑(x, value(eq)))
    return y, dy
end

################################################################

function pow_minus_rule(p, x, k; abstol = 1e-8)
    if !is_univar_poly(p)
        return [p^k, p^(k + 1), log(p), p * log(p)]
    end

    # x = var(p)
    d = poly_deg(p)

    for j in 1:10  # will try 10 times to find the roots
        r, s = find_roots(p, x)
        if length(r) + length(s) >= d
            break
        end
    end
    s = s[1:2:end]
    r = nice_parameter.(r)
    s = nice_parameter.(s)

    # applying ‚à´ 1 / ((x-z‚ÇÅ)(x-z‚ÇÇ)) dx = ... + c‚ÇÅ * log(x-z‚ÇÅ) + c‚ÇÇ * log(x-z‚ÇÇ)
    q = Any[log(x - u) for u in r]
    for i in eachindex(s)
        Œ≤ = s[i]
        if abs(imag(Œ≤)) > abstol
            push!(q, atan((x - real(Œ≤)) / imag(Œ≤)))
            push!(q, (1 + x) * log(x^2 - 2 * real(Œ≤) * x + abs2(Œ≤)))
        else
            push!(q, log(x - real(Œ≤)))
        end
    end
    q = unique(q)

    if k ‚âà -1
        return [[p^k]; q]
    else
        return [[p^k, p^(k + 1)]; q]
    end
end

function sqrt_rule(p, x, k)
    h = Any[p^k, p^(k + 1)]

    Œî = diff(p, x)
    push!(h, log(Œî / 2 + sqrt(p)))

    if !is_univar_poly(p)
        return h
    end

    # x = var(p)

    if poly_deg(p) == 2
        r, s = find_roots(p, x)
        l = leading(p, x)
        if length(r) == 2
            if sum(r) ‚âà 0
                r‚ÇÅ = abs(r[1])
                if l > 0
                    push!(h, acosh(x / r‚ÇÅ))
                else
                    push!(h, asin(x / r‚ÇÅ))
                end
            end
        elseif real(s[1]) ‚âà 0
            push!(h, asinh(x / imag.(s[1])))
        end
    end

    return h
end
